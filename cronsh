#!/bin/bash


# Set variable defaults
CRONSH_ALLOW_MULTIPLE_INSTANCES=yes
#TODO#CRONSH_HARD_DEADLINE_DATESTR=''
CRONSH_ATTEMPTS_MAX=1
CRONSH_ATTEMPTS_TIMEOUT=0
CRONSH_ATTEMPTS_DEADLINE_DATESTR=''
CRONSH_ATTEMPTS_INTERVAL=0
CRONSH_INSTANCE_RANDOM_DELAY=(0 0)
CRONSH_ATTEMPTS_RANDOM_DELAY=(0 0)


# Read config variables passed by CLI argumentum
declare -A config_override
while expr "$1" : '.\+=' >/dev/null
do
	config_override[${1%%=*}]=${1#*=}
	shift
done


# Set Job directory
set -e -u
CRONSH_JOBDIR=$1
if [ "${CRONSH_JOBDIR:0:1}" = / ]
then
	CRONSH_JOBDIR_ABS=$CRONSH_JOBDIR
else
	CRONSH_JOBDIR_ABS=$PWD/$CRONSH_JOBDIR
fi
cd "$CRONSH_JOBDIR"
exec 9>>lock
set +e +u


# Load the job's saved configuration
[ ! -e config ] || . config


# Override config variables with ones passed by CLI args
for var in "${!config_override[@]}"
do
	value=${config_override[$var]}
	eval "$var=\$value"
done
unset var value


# Define subroutines

exit_failure()
{
	[ ! -e post-instance ] || . post-instance
	exit $CRONSH_LAST_STATUS
}
exit_successfull()
{
	exit 0
}
die()
{
	note "$@"
	exit 255
}
note()
{
	echo "cronsh: <$CRONSH_JOBDIR> $*" >&2
}
to_sec()
{
	to_datefmt %s "$@"
}
to_nsec()
{
	to_datefmt %s.%N "$@"
}
to_datefmt()
{
	local fmt=$1
	shift
	if expr "$*" : '^[0-9.]\+$' >/dev/null
	then
		echo "$*"
	else
		date +"$fmt" -d "1970-01-01 00:00 +0000 $*"
	fi
}
check_timeout()
{
	if [ $CRONSH_ATTEMPTS_TIMEOUT != 0 -a $[now - CRONSH_INSTANCE_START_TIMESTAMP] -gt $CRONSH_ATTEMPTS_TIMEOUT ]
	then
		note "instance $CRONSH_INSTANCE_START_TIMESTAMP_NS, attempt $CRONSH_ATTEMPT_NUMBER, attempts timed out ($CRONSH_ATTEMPTS_TIMEOUT sec)"
		exit_failure
	fi
}
check_deadline()
{
	if [ $CRONSH_ATTEMPTS_DEADLINE != 0 -a $now -gt $CRONSH_ATTEMPTS_DEADLINE ]
	then
		note "instance $CRONSH_INSTANCE_START_TIMESTAMP_NS, attempt $CRONSH_ATTEMPT_NUMBER, reached deadline ($(date +"%F %T" -d @$CRONSH_ATTEMPTS_DEADLINE))"
		exit_failure
	fi
}
random_range()
{
	echo $[RANDOM % ($2 + 1 - $1) + $1]
}
sleep()
{
	note "Sleeping $* ..."
	command sleep "$@"
}
human_date_fmt_nsec="%Y-%m-%d_%H:%M:%S.%N"
human_date_fmt_sec="%Y-%m-%d_%H:%M:%S"
human_date_fmt_min="%Y-%m-%d_%H:%M"


# Acquire Lock
if [ $CRONSH_ALLOW_MULTIPLE_INSTANCES = yes ]
then
	flock --shared --nonblock 9 || die "Can not acquire shared lock"
else
	flock --exclusive --nonblock 9 || die "Can not acquire exclusive lock"
fi


# Set computed variables
CRONSH_INSTANCE_START_TIMESTAMP_NS=`date +%s.%N`
CRONSH_INSTANCE_START_TIMESTAMP=${CRONSH_INSTANCE_START_TIMESTAMP_NS%.*}
CRONSH_ATTEMPTS_DEADLINE=0
[ -z "$CRONSH_ATTEMPTS_DEADLINE_DATESTR" ] || CRONSH_ATTEMPTS_DEADLINE=`date +%s -d "$CRONSH_ATTEMPTS_DEADLINE_DATESTR"`
CRONSH_LAST_STATUS=''
CRONSH_ATTEMPTS_TIMEOUT=`to_sec $CRONSH_ATTEMPTS_TIMEOUT`
CRONSH_ATTEMPTS_INTERVAL=`to_nsec $CRONSH_ATTEMPTS_INTERVAL`
CRONSH_ATTEMPT_NUMBER=0
if [ -n "${CRONSH_INSTANCE_RANDOM_DELAY[1]}" ]
then
	CRONSH_INSTANCE_RANDOM_DELAY[0]=`to_sec ${CRONSH_INSTANCE_RANDOM_DELAY[0]}`
	CRONSH_INSTANCE_RANDOM_DELAY[1]=`to_sec ${CRONSH_INSTANCE_RANDOM_DELAY[1]}`
else
	CRONSH_INSTANCE_RANDOM_DELAY=(0 `to_sec "$CRONSH_INSTANCE_RANDOM_DELAY"`)
fi
if [ -n "${CRONSH_ATTEMPTS_RANDOM_DELAY[1]}" ]
then
	CRONSH_ATTEMPTS_RANDOM_DELAY[0]=`to_sec ${CRONSH_ATTEMPTS_RANDOM_DELAY[0]}`
	CRONSH_ATTEMPTS_RANDOM_DELAY[1]=`to_sec ${CRONSH_ATTEMPTS_RANDOM_DELAY[1]}`
else
	CRONSH_ATTEMPTS_RANDOM_DELAY=(0 `to_sec "$CRONSH_ATTEMPTS_RANDOM_DELAY"`)
fi


# Display config variables
set | grep -E ^CRONSH_ | sort >&2

export CRONSH_JOBDIR_ABS
export CRONSH_INSTANCE_START_TIMESTAMP
export CRONSH_ATTEMPT_NUMBER
export CRONSH_LAST_STATUS



# Start the Job

sleep `random_range ${CRONSH_INSTANCE_RANDOM_DELAY[@]}`

[ ! -e pre-instance ] || . pre-instance


while true
do
	let CRONSH_ATTEMPT_NUMBER++
	CRONSH_ATTEMPT_START_TIMESTAMP_NS=`date +%s.%N`
	CRONSH_ATTEMPT_START_TIMESTAMP=${CRONSH_ATTEMPT_START_TIMESTAMP_NS%.*}
	CRONSH_WORKDIR_BASE=work
	CRONSH_ATTEMPTS_BASEDIR=$CRONSH_WORKDIR_BASE/$CRONSH_INSTANCE_START_TIMESTAMP_NS
	CRONSH_ATTEMPT_DIRNAME=attempt-$CRONSH_ATTEMPT_NUMBER
	CRONSH_WORKDIR=$CRONSH_ATTEMPTS_BASEDIR/$CRONSH_ATTEMPT_DIRNAME
	CRONSH_WORKDIR_ABS=$PWD/$CRONSH_WORKDIR
	
	export CRONSH_ATTEMPT_START_TIMESTAMP
	export CRONSH_WORKDIR_ABS

	sleep `random_range ${CRONSH_ATTEMPTS_RANDOM_DELAY[@]}`
	
	[ ! -e pre-attempt ] || . pre-attempt
	
	(
		set -e
		mkdir -p "$CRONSH_WORKDIR"
		
		exec 1>>"$CRONSH_WORKDIR/stdout.txt"
		exec 2>>"$CRONSH_WORKDIR/stderr.txt"
		
		for datefmt in "$human_date_fmt_nsec" "$human_date_fmt_sec" "$human_date_fmt_min"
		do
			ln -sfn "$CRONSH_INSTANCE_START_TIMESTAMP_NS" "$CRONSH_WORKDIR_BASE/$(date -d @$CRONSH_INSTANCE_START_TIMESTAMP_NS +"$datefmt")"
			ln -sfn "$CRONSH_ATTEMPT_DIRNAME" "$CRONSH_ATTEMPTS_BASEDIR/$(date -d @$CRONSH_ATTEMPT_START_TIMESTAMP_NS +"$datefmt")"
		done
		
		cd "$CRONSH_WORKDIR"
		$CRONSH_JOBDIR_ABS/job
	)
	
	CRONSH_LAST_STATUS=$?
	now=`date +%s`
	echo $CRONSH_LAST_STATUS >"$CRONSH_WORKDIR/status"
	note instance "$CRONSH_INSTANCE_START_TIMESTAMP_NS, attempt $CRONSH_ATTEMPT_NUMBER, exit status $CRONSH_LAST_STATUS"
	
	if [ $CRONSH_LAST_STATUS = 0 ]
	then
		exit_successfull
	else
		if [ $CRONSH_ATTEMPTS_MAX != 0 -a $CRONSH_ATTEMPT_NUMBER -ge $CRONSH_ATTEMPTS_MAX ]
		then
			note "instance $CRONSH_INSTANCE_START_TIMESTAMP_NS, attempt $CRONSH_ATTEMPT_NUMBER, reached max attempts $CRONSH_ATTEMPTS_MAX"
			exit_failure
		fi
		check_timeout
		check_deadline
		
		[ ! -e post-attempt ] || . post-attempt
		
		sleep $CRONSH_ATTEMPTS_INTERVAL
		
		now=`date +%s`
		
		check_timeout
		check_deadline
	fi
done

# TODO
# proper termination
# log in foreground
# verbose/debug mode
# standardize IDs in log messages
