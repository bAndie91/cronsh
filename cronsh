#!/bin/bash


# Set variable defaults
CRONSH_ALLOW_MULTIPLE_INSTANCES=yes
CRONSH_ATTEMPTS_MAX=1
CRONSH_ATTEMPTS_TIMEOUT=0
CRONSH_ATTEMPTS_DEADLINE_DATESTR=''
CRONSH_ATTEMPTS_INTERVAL=0
CRONSH_INSTANCE_RANDOM_DELAY=(0 0)
CRONSH_ATTEMPTS_RANDOM_DELAY=(0 0)
CRONSH_ENABLE=yes
CRONSH_STOP_REASON=''


# Read config variables passed by CLI argumentum
declare -A config_override
while expr "$1" : '.\+=' >/dev/null
do
	config_override[${1%%=*}]=${1#*=}
	shift
done


# Set Job directory
set -e -u
CRONSH_JOBDIR=$1
if [ "${CRONSH_JOBDIR:0:1}" = / ]
then
	CRONSH_JOBDIR_ABS=$CRONSH_JOBDIR
else
	CRONSH_JOBDIR_ABS=$PWD/$CRONSH_JOBDIR
fi
cd "$CRONSH_JOBDIR"
# Open file descriptor to lock later on
exec {CRONSH_LOCK_FD}>>lock
set +e +u


# Load the job's saved configuration
[ ! -e config ] || . config


# Override config variables with ones passed by CLI args
for var in "${!config_override[@]}"
do
	value=${config_override[$var]}
	eval "$var=\$value"
done
unset var value


# Define subroutines

set -e
for libdir in "$(dirname "`readlink -f "$0"`")" /usr/lib/cronsh /usr/share/cronsh ""
do
	if [ -z "$libdir" ]
	then
		echo "can not source cronsh-common" >&2
		false
	fi
	if [ -e "$libdir/cronsh-common" ]
	then
		. "$libdir/cronsh-common"
		break
	fi
done
set +e

exit_cronsh()
{
	[ ! -e post-instance ] || . post-instance
	
	if [ "$CRONSH_LAST_STATUS" != 0 ]
	then
		[ ! -e failure ] || ./failure
	else
		[ ! -e success ] || ./success
	fi
	
	echo -n '' >"$CRONSH_INSTANCE_WORKDIR/end"
	
	exit ${CRONSH_LAST_STATUS:-255}
}
check_timeout()
{
	local now=`date +%s`
	if [ $CRONSH_ATTEMPTS_TIMEOUT != 0 -a $[now - CRONSH_INSTANCE_START_TIMESTAMP] -gt $CRONSH_ATTEMPTS_TIMEOUT ]
	then
		CRONSH_STOP_REASON=attempt-timeout
		note "attempting is timed out at attempt $CRONSH_ATTEMPT_NUMBER ($CRONSH_ATTEMPTS_TIMEOUT sec)"
		exit_cronsh
	fi
}
check_deadline()
{
	local now=`date +%s`
	if [ $CRONSH_ATTEMPTS_DEADLINE != 0 -a $now -gt $CRONSH_ATTEMPTS_DEADLINE ]
	then
		CRONSH_STOP_REASON=attempt-deadline
		note "reached deadline ($(date +"%F %T" -d @$CRONSH_ATTEMPTS_DEADLINE)) at attempt $CRONSH_ATTEMPT_NUMBER"
		exit_cronsh
	fi
}
random_range()
{
	echo $[RANDOM % ($2 + 1 - $1) + $1]
}
sleep()
{
	local t=$1
	shift
	[ "$t" != 0 ] || return
	note "sleep $t: $*"
	command sleep "$t" {CRONSH_LOCK_FD}>&- {CRONSH_INSTANCE_LOCK_FD}>&-
}

cronsh_termination()
{
	CRONSH_STOP_REASON=terminate
	
	if [ -n "$CRONSH_ATTEMPT_PID" ]
	then
		note "Terminating Job ($CRONSH_ATTEMPT_PID) ..."
		kill -s TERM $CRONSH_ATTEMPT_PID
	else
		exit_cronsh
	fi
}

trap 'cronsh_termination' TERM


if [ $CRONSH_ENABLE != yes ]
then
	die "Job is disabled."
fi


# Acquire Lock
if [ $CRONSH_ALLOW_MULTIPLE_INSTANCES = yes ]
then
	flock --shared --nonblock $CRONSH_LOCK_FD || die "Can not acquire shared lock"
else
	flock --exclusive --nonblock $CRONSH_LOCK_FD || die "Can not acquire exclusive lock"
fi


# Generate instance unique variables
CRONSH_INSTANCE_START_TIMESTAMP_NS=`date +%s.%N`
CRONSH_INSTANCE_START_TIMESTAMP=${CRONSH_INSTANCE_START_TIMESTAMP_NS%.*}
CRONSH_WORKDIR_BASE=work
CRONSH_ATTEMPTS_BASEDIR=$CRONSH_WORKDIR_BASE/$CRONSH_INSTANCE_START_TIMESTAMP_NS
CRONSH_INSTANCE_WORKDIR=$CRONSH_ATTEMPTS_BASEDIR

# Save Job Instance's PID and setup logging
set -e
mkdir -p "$CRONSH_INSTANCE_WORKDIR"
echo -n $$ >"$CRONSH_INSTANCE_WORKDIR/pid"
exec {CRONSH_INSTANCE_LOCK_FD}>>"$CRONSH_INSTANCE_WORKDIR/pid"
flock --exclusive --nonblock $CRONSH_INSTANCE_LOCK_FD
exec {stdout_copy}>&1
exec {stderr_copy}>&2
exec 1> >(exec tee "$CRONSH_INSTANCE_WORKDIR/stdout.txt" >&1)
exec 2> >(exec tee "$CRONSH_INSTANCE_WORKDIR/stderr.txt" >&2)
set +e


# Set other computed variables
CRONSH_ATTEMPTS_DEADLINE=0
[ -z "$CRONSH_ATTEMPTS_DEADLINE_DATESTR" ] || CRONSH_ATTEMPTS_DEADLINE=`date +%s -d "$CRONSH_ATTEMPTS_DEADLINE_DATESTR"`
CRONSH_LAST_STATUS=''
CRONSH_ATTEMPTS_TIMEOUT=`to_sec $CRONSH_ATTEMPTS_TIMEOUT`
CRONSH_ATTEMPTS_INTERVAL=`to_nsec $CRONSH_ATTEMPTS_INTERVAL`
CRONSH_ATTEMPT_NUMBER=0
if [ -n "${CRONSH_INSTANCE_RANDOM_DELAY[1]}" ]
then
	CRONSH_INSTANCE_RANDOM_DELAY[0]=`to_sec ${CRONSH_INSTANCE_RANDOM_DELAY[0]}`
	CRONSH_INSTANCE_RANDOM_DELAY[1]=`to_sec ${CRONSH_INSTANCE_RANDOM_DELAY[1]}`
else
	CRONSH_INSTANCE_RANDOM_DELAY=(0 `to_sec "$CRONSH_INSTANCE_RANDOM_DELAY"`)
fi
if [ -n "${CRONSH_ATTEMPTS_RANDOM_DELAY[1]}" ]
then
	CRONSH_ATTEMPTS_RANDOM_DELAY[0]=`to_sec ${CRONSH_ATTEMPTS_RANDOM_DELAY[0]}`
	CRONSH_ATTEMPTS_RANDOM_DELAY[1]=`to_sec ${CRONSH_ATTEMPTS_RANDOM_DELAY[1]}`
else
	CRONSH_ATTEMPTS_RANDOM_DELAY=(0 `to_sec "$CRONSH_ATTEMPTS_RANDOM_DELAY"`)
fi


# Expose instance specific variables
export CRONSH_JOBDIR_ABS
export CRONSH_INSTANCE_START_TIMESTAMP
export CRONSH_ATTEMPT_NUMBER
export CRONSH_LAST_STATUS


# Display config variables
set | grep -E ^CRONSH_ | sort | sed -e 's/^/env: /' >&2


# Start the Job

sleep `random_range ${CRONSH_INSTANCE_RANDOM_DELAY[@]}` random delay before starting job

[ ! -e pre-instance ] || . pre-instance


while true
do
	let CRONSH_ATTEMPT_NUMBER++
	CRONSH_ATTEMPT_START_TIMESTAMP_NS=`date +%s.%N`
	CRONSH_ATTEMPT_START_TIMESTAMP=${CRONSH_ATTEMPT_START_TIMESTAMP_NS%.*}
	CRONSH_ATTEMPT_DIRNAME=attempt-$CRONSH_ATTEMPT_NUMBER
	CRONSH_WORKDIR=$CRONSH_ATTEMPTS_BASEDIR/$CRONSH_ATTEMPT_DIRNAME
	CRONSH_WORKDIR_ABS=$PWD/$CRONSH_WORKDIR
	
	# Expose attempt specific variables
	export CRONSH_ATTEMPT_START_TIMESTAMP
	export CRONSH_WORKDIR_ABS
	
	if [ $CRONSH_ATTEMPT_NUMBER -gt 1 ]
	then
		sleep `random_range ${CRONSH_ATTEMPTS_RANDOM_DELAY[@]}` random delay before an attempt
		check_timeout
		check_deadline
	fi
	
	[ ! -e pre-attempt ] || . pre-attempt
	
	(
		set -e
		mkdir -p "$CRONSH_WORKDIR"
		
		exec 1> >(exec tee "$CRONSH_WORKDIR/stdout.txt" >&$stdout_copy)
		exec 2> >(exec tee "$CRONSH_WORKDIR/stderr.txt" >&$stderr_copy)
		
		for datefmt in "$human_date_fmt_nsec" "$human_date_fmt_sec" "$human_date_fmt_min"
		do
			ln -sfn "$CRONSH_INSTANCE_START_TIMESTAMP_NS" "$CRONSH_WORKDIR_BASE/$(date -d @$CRONSH_INSTANCE_START_TIMESTAMP_NS +"$datefmt")"
			ln -sfn "$CRONSH_ATTEMPT_DIRNAME" "$CRONSH_ATTEMPTS_BASEDIR/$(date -d @$CRONSH_ATTEMPT_START_TIMESTAMP_NS +"$datefmt")"
		done
		
		cd "$CRONSH_WORKDIR"
		renice -n 19 -p $$ >/dev/null
		# ??? # {CRONSH_LOCK_FD}>&- {CRONSH_INSTANCE_LOCK_FD}>&-
		ionice -c 3 -p $$
		exec setsid bash -c '
			set -e;
			pidfile=$CRONSH_WORKDIR_ABS/pid;
			exec {CRONSH_ATTEMPT_LOCK_FD}>"$pidfile";
			echo -n $$ >&$CRONSH_ATTEMPT_LOCK_FD;
			flock --exclusive --nonblock $CRONSH_ATTEMPT_LOCK_FD;
			exec cronsh_loadenv "$CRONSH_JOBDIR_ABS/env" "$CRONSH_JOBDIR_ABS/job";
		'
	) &
	CRONSH_ATTEMPT_PID=$!
	wait $CRONSH_ATTEMPT_PID
	
	CRONSH_LAST_STATUS=$?
	CRONSH_ATTEMPT_PID=''
	echo -n $CRONSH_LAST_STATUS >"$CRONSH_WORKDIR/status"
	note "exit status $CRONSH_LAST_STATUS at attempt $CRONSH_ATTEMPT_NUMBER"
	
	if [ "$CRONSH_STOP_REASON" = terminate ]
	then
		exit_cronsh
	fi
	
	if [ $CRONSH_LAST_STATUS = 0 ]
	then
		exit_cronsh
	else
		if [ $CRONSH_ATTEMPTS_MAX != 0 -a $CRONSH_ATTEMPT_NUMBER -ge $CRONSH_ATTEMPTS_MAX ]
		then
			CRONSH_STOP_REASON=attempt-limit
			note "reached max attempts ($CRONSH_ATTEMPTS_MAX)"
			exit_cronsh
		fi
		check_timeout
		check_deadline
		
		[ ! -e post-attempt ] || . post-attempt
		
		sleep $CRONSH_ATTEMPTS_INTERVAL between attempts
		
		check_timeout
		check_deadline
	fi
done

# TODO
# proper termination
# CRONSH_SHOULD_RUN time spec
# emulate terminal
# invocation: recursive
# timeout ./job according to CRONSH_JOB_TIMEOUT and CRONSH_JOB_DEADLINE
# verbose/debug mode
# detect config change and reload
