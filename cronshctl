#!/bin/bash


set -e
for libdir in "$(dirname "`readlink -f "$0"`")" /usr/lib/cronsh /usr/share/cronsh ""
do
	if [ -z "$libdir" ]
	then
		echo "can not source cronsh-common" >&2
		false
	fi
	if [ -e "$libdir/cronsh-common" ]
	then
		. "$libdir/cronsh-common"
		break
	fi
done
set +e



find_last_attempt_number()
{
	find "$1" -maxdepth 1 -name 'attempt-*' -printf "%f\n" | cut -f2 -d- | sort -n | tail -n 1
}
find_last_attempt_pid()
{
	local lastattempt=`find_last_attempt_number "$1"`
	cat "$1/attempt-$lastattempt/pid"
}
find_current_attempt_pid()
{
	local lastattempt=`find_last_attempt_number "$1"`
	if [ ! -e "$1/attempt-$lastattempt/status" ]
	then
		local pidfile=$1/attempt-$lastattempt/pid
		if [ -e "$pidfile" ] && is_locked "$pidfile"
		then
			cat "$pidfile" 2>/dev/null
		fi
	fi
}


shopt -s extglob

cmd=$1
shift

case "$cmd" in
ls)
	usage()
	{
		echo "Usage: cronshctl ls [--last | -l [N]]] [--all | -a] [<job-directory>]" >&2
	}
	
	show_last_n=''
	show_active_only=yes
	
	while [ -n "$1" ]
	do
		case "$1" in
		-l|--last)
			show_active_only=no
			if [ "$2" -ge 0 ] 2>/dev/null
			then
				show_last_n=$2
				shift
			else
				show_last_n=1
			fi
			;;
		-a|--all)
			show_active_only=no
			;;
		-h|--help)
			usage
			exit 0
			;;
		--)	shift; break;;
		-*)	die "unknown option: $1";;
		*)	break;;
		esac
		shift
	done
	
	[ -d "$1" ] || { usage; exit 2; }
	CRONSH_JOBDIR=$1
	shift
	cd "$CRONSH_JOBDIR/work" || die
	
	all_instances=(+([0-9]).+([0-9]))
	show_instances=("${all_instances[@]}")
	
	if [ -n "$show_last_n" ]
	then
		if [ $show_last_n -lt ${#all_instances[@]} ]
		then
			show_instances=()
			for ((i=show_last_n; i>=1; i--)) { show_instances+=("${all_instances[-$i]}"); }
		fi
	fi
	
	
	# print header
	fmt="%5s\t%-${human_date_fmt_ls_width}s\t%-${human_date_fmt_ls_width}s\t%3s\t%5s\t%1s\n"
	printf "$fmt" PID STARTED ENDED "LAST STATUS" "CURRENT ATTEMPT PID" "ATTEMPTS"
	
	
	for instancedir in "${show_instances[@]}"
	do
		instance_started_nsec=${instancedir##*/}
		
		if is_locked $instancedir/pid
		then
			instancepid=`cat "$instancedir/pid" 2>/dev/null`
		else
			if [ $show_active_only = yes ]
			then
				continue
			fi
			instancepid=''
		fi
		
		started=`date +"$human_date_fmt_ls" -d @$instance_started_nsec`
		ended=`date +"$human_date_fmt_ls" -r "$instancedir/end" 2>/dev/null`
		attempts=`find_last_attempt_number "$instancedir"`
		
		if [ -e "$instancedir/attempt-$attempts/status" ]
		then
			# this job attempt is ended
			lastattempt=$attempts
			attemptpid=''
		else
			# this job attempt is in progress
			lastattempt=$[attempts - 1]
			pidfile=$instancedir/attempt-$attempts/pid
			if [ -e "$pidfile" ] && is_locked "$pidfile" 
			then
				attemptpid=`cat "$pidfile"`
			else
				attemptpid=''
			fi
		fi
		laststatus=`cat "$instancedir/attempt-$lastattempt/status" 2>/dev/null`
		
		printf "$fmt" "$instancepid" "$started" "$ended" "$laststatus" "$attemptpid" "$attempts"
	done
	;;

stop)
	usage()
	{
		echo "Usage: cronshctl stop [-g | --pgroup] [<job-directory> | <job-instance-directory>]" >&2
	}
	
	terminate_pgroup=no
	
	while [ -n "$1" ]
	do
		case "$1" in
		-g|--pgroup)
			terminate_pgroup=yes
			;;
		-h|--help)
			usage
			exit 0
			;;
		--)	shift; break;;
		-*)	die "unknown option: $1";;
		*)	break;;
		esac
		shift
	done
	
	[ -d "$1" ] || { usage; exit 2; }
	if [ -e "$1/lock" ]
	then
		CRONSH_JOBDIR=$1
		CRONSH_INSTANCE_WORKDIR=''
	else
		CRONSH_INSTANCE_WORKDIR=`readlink -f "$1"`
		CRONSH_JOBDIR=`dirname "$(dirname "$CRONSH_INSTANCE_WORKDIR")"`
	fi
	shift
	
	
	for instancedir in "$CRONSH_INSTANCE_WORKDIR" # TODO
	do
		if is_locked "$instancedir/pid"
		then
			instancepid=`cat "$instancedir/pid"`
			check_interval=1
			pgroup_kill_delay=2
			pgroup_signal_sent=no
			
			# First inform Job Instance process about termination
			kill -s TERM $instancepid
			signal_time=`date +%s`
			
			echo -n "Wait for termination " >&2
			
			# This single-iteration loop enable us to "break 2" from the inner loop
			for x in 1
			do
				# Wait until Job terminates itself
				while is_locked "$instancedir/pid"
				do
					attemptpid=`find_last_attempt_pid "$instancedir"`
					
					if [ -n "$attemptpid" ]
					then
						if [ $terminate_pgroup = yes -a $pgroup_signal_sent = no ]
						then
							if [ $[signal_time + pgroup_kill_delay] -lt `date +%s` ]
							then
								echo "Terminate Job's Process Group" >&2
								kill -s TERM -- -$attemptpid
								pgroup_signal_sent=yes
								echo -n "Wait for termination " >&2
							fi
						fi
					fi
					
					sleep $check_interval
					echo -n "." >&2
				done
				
				echo "DONE" >&2
			done
		fi
	done
	;;
esac
