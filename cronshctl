#!/bin/bash


set -e
enable kill
for libdir in "$(dirname "`readlink -f "$0"`")" /usr/lib/cronsh /usr/share/cronsh ""
do
	if [ -z "$libdir" ]
	then
		echo "can not source cronsh-common" >&2
		false
	fi
	if [ -e "$libdir/cronsh-common" ]
	then
		. "$libdir/cronsh-common"
		break
	fi
done
set +e



find_last_attempt_number()
{
	find "$1" -maxdepth 1 -name 'attempt-*' -printf "%f\n" | cut -f2 -d- | sort -n | tail -n 1
}
find_last_attempt_pid()
{
	local lastattempt=`find_last_attempt_number "$1"`
	cat "$1/attempt-$lastattempt/pid"
}
find_current_attempt_pid()
{
	local lastattempt=`find_last_attempt_number "$1"`
	if [ ! -e "$1/attempt-$lastattempt/status" ]
	then
		local pidfile=$1/attempt-$lastattempt/pid
		if is_locked "$pidfile"
		then
			cat "$pidfile" 2>/dev/null
		fi
	fi
}


shopt -s extglob
shopt -s nullglob

cmd=$1
shift

case "$cmd" in
ls)
	usage()
	{
		echo "Usage: cronshctl ls [--last | -l [<N>]] [--all | -a] [<job-directory>]" >&2
	}
	
	show_last_n=''
	show_active_only=yes
	
	while [ -n "$1" ]
	do
		case "$1" in
		-l|--last)
			show_active_only=no
			if [ "$2" -ge 0 ] 2>/dev/null
			then
				show_last_n=$2
				shift
			else
				show_last_n=1
			fi
			;;
		-a|--all)
			show_active_only=no
			;;
		-h|--help)
			usage
			exit 0
			;;
		--)	shift; break;;
		-*)	die "unknown option: $1";;
		*)	break;;
		esac
		shift
	done
	
	[ -d "$1" ] || { usage; exit 2; }
	CRONSH_JOBDIR=$1
	shift
	cd "$CRONSH_JOBDIR/work" || die
	
	all_instances=(+([0-9]).+([0-9]))
	show_instances=("${all_instances[@]}")
	
	if [ -n "$show_last_n" ]
	then
		if [ $show_last_n -lt ${#all_instances[@]} ]
		then
			show_instances=()
			for ((i=show_last_n; i>=1; i--)) { show_instances+=("${all_instances[-$i]}"); }
		fi
	fi
	
	
	# print header
	fmt="%5s\t%-${human_date_fmt_ls_width}s\t%-${human_date_fmt_ls_width}s\t%3s\t%5s\t%1s\n"
	printf "$fmt" PID STARTED ENDED "LAST STATUS" "CURRENT ATTEMPT PID" "ATTEMPTS"
	
	
	for instancedir in "${show_instances[@]}"
	do
		instance_started_nsec=${instancedir##*/}
		
		if is_locked $instancedir/pid
		then
			instancepid=`cat "$instancedir/pid" 2>/dev/null`
		else
			if [ $show_active_only = yes ]
			then
				continue
			fi
			instancepid=''
		fi
		
		started=`date +"$human_date_fmt_ls" -d @$instance_started_nsec`
		ended=`date +"$human_date_fmt_ls" -r "$instancedir/end" 2>/dev/null`
		attempts=`find_last_attempt_number "$instancedir"`
		
		if [ -e "$instancedir/attempt-$attempts/status" ]
		then
			# this job attempt is ended
			lastattempt=$attempts
			attemptpid=''
		else
			# this job attempt is in progress
			lastattempt=$[attempts - 1]
			pidfile=$instancedir/attempt-$attempts/pid
			if is_locked "$pidfile"
			then
				attemptpid=`cat "$pidfile"`
			else
				attemptpid=''
			fi
		fi
		laststatus=`cat "$instancedir/attempt-$lastattempt/status" 2>/dev/null`
		
		printf "$fmt" "$instancepid" "$started" "$ended" "$laststatus" "$attemptpid" "$attempts"
	done
	;;

stop)
	usage()
	{
		echo "Usage: cronshctl stop [-g | --pgroup] [<job-directory> | <job-instance-directory> [<dir> [...]]]" >&2
	}
	
	terminate_pgroup=no
	check_interval=1
	pgroup_signal_sent=no
	pgroup_kill_delay=2
	instance_workdirs=()
	active_instance_workdirs=()
	declare -A pending_instances=()
	
	while [ -n "$1" ]
	do
		case "$1" in
		-g|--pgroup)
			terminate_pgroup=yes
			;;
		-h|--help)
			usage
			exit 0
			;;
		--)	shift; break;;
		-*)	die "unknown option: $1";;
		*)	break;;
		esac
		shift
	done
	
	[ -d "$1" ] || { usage; exit 2; }
	
	while [ -n "$1" ]
	do
		if [ -e "$1/lock" ]
		then
			# If there is a file called "lock" in the directory, we count it as a Job Root dir
			# and add all instance directories to the list, as it'll be filtered later;
			instance_workdirs+=( "$1"/work/+([0-9]).+([0-9]) )
		else
			# Otherwise it's must be a Job Instance dir
			instance_workdirs+=( "$1" )
		fi
		shift
	done
	
	
	# Signal Job Instance processes
	for instancedir in "${instance_workdirs[@]}"
	do
		# Filter for active Job Instances only
		if is_locked "$instancedir/pid"
		then
			# First inform Job Instance process about termination
			instancepid=`cat "$instancedir/pid"`
			kill -s TERM $instancepid  # FIXME it may kill unrelated process who reused this pid
			pending_instances[$instancedir]=$instancepid
			active_instance_workdirs+=("$instancedir")
		fi
	done
	signal_time=`date +%s`
	
	
	while true
	do
		for instancedir in "${!pending_instances[@]}"
		do
			if ! is_locked "$instancedir/pid"
			then
				unset "pending_instances[$instancedir]"
			fi
		done
		
		if [ ${#pending_instances[@]} = 0 ]
		then
			break
		fi
		
		echo "Wait for termination (${#pending_instances[@]}/${#active_instance_workdirs[@]})" >&2
		
		if [ $terminate_pgroup = yes -a $pgroup_signal_sent = no ]
		then
			if [ $[signal_time + pgroup_kill_delay] -le `date +%s` ]
			then
				echo "Terminate Job's Process Group" >&2
				
				for instancedir in "${!pending_instances[@]}"
				do
					attemptpid=`find_last_attempt_pid "$instancedir"`
					if [ -n "$attemptpid" ]
					then
						kill -s TERM -- -$attemptpid  # FIXME sometimes not exists
					fi
				done
				
				pgroup_signal_sent=yes
			fi
		fi
		
		sleep $check_interval
	done
	;;

*)
	echo "cronshctl [ls | stop]" >&2
	exit 1
	;;
esac
